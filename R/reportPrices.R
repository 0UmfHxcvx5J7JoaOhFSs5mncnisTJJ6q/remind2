#' Read in GDX and calculate prices, used in convGDX2MIF.R for the reporting
#'
#' Read in price information from GDX file, information used in convGDX2MIF.R
#' for the reporting
#'
#'
#' @param gdx a GDX object as created by readGDX, or the path to a gdx
#' @param output a magpie object containing all needed variables generated by other report*.R functions
#' @param regionSubsetList a list containing regions to create report variables region
#' aggregations. If NULL (default value) only the global region aggregation "GLO" will
#' be created.
#' @param t temporal resolution of the reporting, default:
#' t=c(seq(2005,2060,5),seq(2070,2110,10),2130,2150)
#'
#' @return MAgPIE object - contains the price variables
#' @importFrom luscale speed_aggregate
#' @author David Klein
#' @seealso \code{\link{convGDX2MIF}}
#' @examples
#'
#' \dontrun{reportPrices(gdx)}
#'
#' @importFrom dplyr %>% case_when distinct filter inner_join tibble
#' @importFrom gdx readGDX
#' @importFrom luscale speed_aggregate
#' @importFrom magclass mbind getYears getRegions setNames dimSums new.magpie lowpass complete_magpie
#' @importFrom quitte df.2.named.vector getColValues
#' @importFrom readr read_csv
#' @importFrom madrat toolAggregate
#'

#' @export
reportPrices <- function(gdx,output=NULL,regionSubsetList=NULL,t=c(seq(2005,2060,5),seq(2070,2110,10),2130,2150)) {

  ### FS: start new price reporting
  #(from price parameters calculated in core/postsolve.gms)

  module2realisation <- readGDX(gdx, "module2realisation")
  rownames(module2realisation) <- module2realisation$modules


  pm_FEPrice <- readGDX(gdx, "pm_FEPrice", restore_zeros = F)
  pm_SEPrice <- readGDX(gdx, "pm_SEPrice", restore_zeros = F)
  p_PEPrice <- readGDX(gdx, "p_PEPrice", restore_zeros = F)
  vm_demFeSector <- readGDX(gdx, "vm_demFeSector", field = "l", restore_zeros = F)[,t,]
  demSe          <- readGDX(gdx,name=c("vm_demSe","v_demSe"),
                            types="variables",field="l",format="first_found",
                            restore_zeros=FALSE)[,t,]

  tdptwyr2dpgj <- 31.71   # conversion factor trUSD2005/TWa to USD2005/GJ

  ## weights for market aggregtion of prices: FE share of market
  p_weights_FEprice_mkt <- dimSums(vm_demFeSector, dim=3.1, na.rm = T) / dimSums(vm_demFeSector, dim=c(3.1,3.4), na.rm = T)
  p_weights_FEprice_mkt[is.na(p_weights_FEprice_mkt)] <- 0
  ## adjust to pm_FEprice dimensions
  p_weights_FEprice_mkt <- p_weights_FEprice_mkt[,getYears(pm_FEPrice),getNames(pm_FEPrice)]

  ## weights for fepet/fedie to liquids aggregtion of prices: FE fepet/fedie share of aggregated markets
  p_weights_FEprice_diepet <- dimSums(mselect(vm_demFeSector, all_enty1=c("fedie","fepet"), emi_sectors="trans"), dim=c(3.1,3.4), na.rm = T) /
    dimSums(mselect(vm_demFeSector, all_enty1=c("fedie","fepet"), emi_sectors="trans"), dim=c(3.1,3.2,3.4), na.rm = T)
  p_weights_FEprice_diepet[is.na(p_weights_FEprice_diepet)] <- 0
  p_weights_FEprice_diepet <- p_weights_FEprice_diepet[,getYears(pm_FEPrice),]

  out <- NULL

  ## calculate prices as weighted average prices across markets
  ## FE Transport Prices
  out <- mbind(
    out,
    setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="feelt", emi_sectors = "trans"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
             "Price|Final Energy|Transport|Electricity (US$2005/GJ)"),
    ## in case of transport liquids: calculate weighted average of markets first, then calculate weighted average of fepet/fedie
    setNames( dimSums( p_weights_FEprice_diepet * dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1=c("fepet","fedie"), emi_sectors = "trans"), dim=3.3, na.rm = T), dim=3.1, na.rm = T)*tdptwyr2dpgj,
             "Price|Final Energy|Transport|Liquids (US$2005/GJ)"),
    setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="feh2t", emi_sectors = "trans"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
             "Price|Final Energy|Transport|Hydrogen (US$2005/GJ)")
  )

  if (module2realisation["transport",2] == "edge_esm") {
    out <- mbind(
      out,
      setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="fegat", emi_sectors = "trans"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
               "Price|Final Energy|Transport|Gases (US$2005/GJ)"))
  }


  ## FE Buildings Prices
  out <- mbind(out,
               setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="feels", emi_sectors = "build"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
                        "Price|Final Energy|Buildings|Electricity (US$2005/GJ)"),
               setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="fegas", emi_sectors = "build"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
                        "Price|Final Energy|Buildings|Gases (US$2005/GJ)"),
               setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="feh2s", emi_sectors = "build"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
                        "Price|Final Energy|Buildings|Hydrogen (US$2005/GJ)"),
               setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="fehos", emi_sectors = "build"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
                        "Price|Final Energy|Buildings|Liquids (US$2005/GJ)"),
               setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="fehes", emi_sectors = "build"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
                        "Price|Final Energy|Buildings|Heat (US$2005/GJ)"),
               setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="fesos", emi_sectors = "build"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
                        "Price|Final Energy|Buildings|Solids (US$2005/GJ)")
               )

  ## FE Industry Prices
  out <- mbind(out,
               setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="feels", emi_sectors = "indst"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
                        "Price|Final Energy|Industry|Electricity (US$2005/GJ)"),
               setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="fegas", emi_sectors = "indst"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
                        "Price|Final Energy|Industry|Gases (US$2005/GJ)"),
               setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="feh2s", emi_sectors = "indst"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
                        "Price|Final Energy|Industry|Hydrogen (US$2005/GJ)"),
               setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="fehos", emi_sectors = "indst"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
                        "Price|Final Energy|Industry|Liquids (US$2005/GJ)"),
               setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="fehes", emi_sectors = "indst"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
                        "Price|Final Energy|Industry|Heat (US$2005/GJ)"),
               setNames( dimSums(mselect(p_weights_FEprice_mkt * pm_FEPrice, all_enty1="fesos", emi_sectors = "indst"), dim=3.3, na.rm = T)*tdptwyr2dpgj,
                        "Price|Final Energy|Industry|Solids (US$2005/GJ)")
               )

  ## SE Prices
  out <- mbind(out,
               setNames(mselect(pm_SEPrice, all_enty="seliqfos")*tdptwyr2dpgj,
                        "Price|Secondary Energy|Liquids|Fossil (US$2005/GJ)"),
               setNames(mselect(pm_SEPrice, all_enty="seliqbio")*tdptwyr2dpgj,
                        "Price|Secondary Energy|Liquids|Biomass (US$2005/GJ)"),
               setNames(mselect(pm_SEPrice, all_enty="seliqsyn")*tdptwyr2dpgj,
                        "Price|Secondary Energy|Liquids|Hydrogen (US$2005/GJ)"),
               setNames(mselect(pm_SEPrice, all_enty="sesobio")*tdptwyr2dpgj,
                        "Price|Secondary Energy|Solids|Biomass (US$2005/GJ)"),
               setNames(mselect(pm_SEPrice, all_enty="sesofos")*tdptwyr2dpgj,
                        "Price|Secondary Energy|Solids|Fossil (US$2005/GJ)"),
               setNames(mselect(pm_SEPrice, all_enty="seel")*tdptwyr2dpgj,
                        "Price|Secondary Energy|Electricity (US$2005/GJ)"),
               setNames(mselect(pm_SEPrice, all_enty="seh2")*tdptwyr2dpgj,
                        "Price|Secondary Energy|Hydrogen (US$2005/GJ)"),
               setNames(mselect(pm_SEPrice, all_enty="segabio")*tdptwyr2dpgj,
                        "Price|Secondary Energy|Gases|Biomass (US$2005/GJ)"),
               setNames(mselect(pm_SEPrice, all_enty="segafos")*tdptwyr2dpgj,
                        "Price|Secondary Energy|Gases|Fossil (US$2005/GJ)"),
               setNames(mselect(pm_SEPrice, all_enty="segasyn")*tdptwyr2dpgj,
                        "Price|Secondary Energy|Gases|Hydrogen (US$2005/GJ)"),
               setNames(mselect(pm_SEPrice, all_enty="sehe")*tdptwyr2dpgj,
                        "Price|Secondary Energy|Heat (US$2005/GJ)")
               )


  ## PE Prices
  out <- mbind(out,
               setNames(mselect(p_PEPrice, all_enty="peoil")*tdptwyr2dpgj,
                        "Price|Primary Energy|Oil (US$2005/GJ)"),
               setNames(mselect(p_PEPrice, all_enty="pegas")*tdptwyr2dpgj,
                        "Price|Primary Energy|Gas (US$2005/GJ)"),
               setNames(mselect(p_PEPrice, all_enty="pecoal")*tdptwyr2dpgj,
                        "Price|Primary Energy|Coal (US$2005/GJ)"),
               setNames(mselect(p_PEPrice, all_enty="peur")*tdptwyr2dpgj,
                        "Price|Primary Energy|Nuclear (US$2005/GJ)"),
               ## only modern (ligno-cellulosic) biomass reported
               setNames(mselect(p_PEPrice, all_enty="pebiolc")*tdptwyr2dpgj,
                        "Price|Primary Energy|Biomass|Modern (US$2005/GJ)"),
               setNames(mselect(p_PEPrice, all_enty="pebios")*tdptwyr2dpgj,
                        "Price|Primary Energy|Biomass|1st Generation|Sugar and Starch (US$2005/GJ)"),
               setNames(mselect(p_PEPrice, all_enty="pebios")*tdptwyr2dpgj,
                        "Price|Primary Energy|Biomass|1st Generation|Oil-based (US$2005/GJ)")
               )

  ## apply lowpass filter to receive moving average prices
  out.lowpass <- lowpass(out)
  ## add "Moving Avg" to variable name
  getNames(out.lowpass) <- paste0(substr(getNames(out.lowpass),
                                         1,nchar(getNames(out.lowpass))-13),
                                  "|Moving Avg",
                                  substr(getNames(out.lowpass),
                                         nchar(getNames(out.lowpass))-12,
                                         nchar(getNames(out.lowpass))))
  ## bind to output object
  out <- mbind(out,out.lowpass)

  ## add years before cm_startyear (temporary, can be adapted once prices only calculated after cm_startyear in REMIND code)
  out2 <- new.magpie(getRegions(out), getYears(vm_demFeSector), getNames(out), fill = NA)
  out2[,getYears(out), ] <- out

  out <- out2


  ### end new price reporting

  if(is.null(output)){
    output <- reportPE(gdx,regionSubsetList = regionSubsetList,t = t)
    output <- mbind(output,reportSE(gdx,regionSubsetList = regionSubsetList,t = t))
    output <- mbind(output,reportFE(gdx,regionSubsetList = regionSubsetList,t = t))
    output <- mbind(output,reportEmi(gdx,regionSubsetList = regionSubsetList,t = t))
    output <- mbind(output,reportExtraction(gdx,regionSubsetList = regionSubsetList,t = t))
    output <- mbind(output,reportMacroEconomy(gdx,regionSubsetList = regionSubsetList,t = t)[,getYears(output),])
  }

  #---- Functions
  find_real_module <- function(module_set, module_name){
    return(module_set[module_set$modules == module_name,2])
  }


  #---- End of Functions

  ####### get realisations #########
  realisation <- readGDX(gdx, "module2realisation")

  ####### get power realisations #########
  realisation <- readGDX(gdx, "module2realisation")
  power_realisation <- if ("power" %in% realisation[, 1]) realisation[which(realisation[,1] == "power"),2]

  ####### conversion factors ##########
  s_GWP_CH4 <- readGDX(gdx,c("sm_gwpCH4","s_gwpCH4","s_GWP_CH4"),format="first_found", react = "silent")
  s_GWP_N2O <- readGDX(gdx,c("s_gwpN2O","s_GWP_N2O"),format="first_found", react = "silent")
  TWa_2_EJ     <- 31.536
  tdptwyr2dpgj <- 31.71   #TerraDollar per TWyear to Dollar per GJ
  p80_subset   <- c("perm","good","peur","peoil","pegas","pecoal","pebiolc") #TODO: read in from gdx as sets trade
  pebal_subset <- c("pebiolc","peoil","pegas","pecoal","peur")
  ####### read in needed data #########
  ## sets
  fe_transp_fety35 <- readGDX(gdx,name="FE_Transp_fety35",types="sets",format="first_found", react = "silent")
  se2fe          <- readGDX(gdx,name="se2fe",types="sets",format="first_found", react = "silent")
  sety           <- readGDX(gdx,c("entySe","sety"),types="sets",format="first_found", react = "silent")
  fety           <- readGDX(gdx,name=c("entyFe","fety"),types="sets",format="first_found", react = "silent")
  finenbal       <- readGDX(gdx,name=c("fe2ppfEn","finenbal"),types="sets",format="first_found", react = "silent")
  all_esty       <- readGDX(gdx,name=c("all_esty"),types="sets",format="first_found", react = "silent")
  if(!is.null(all_esty)){
  fe2es          <- readGDX(gdx,name=c("fe2es"),types="sets",format="first_found", react = "silent")
  fe2es          <- unique(fe2es[c("all_enty","all_esty")])
  colnames(fe2es) <- gsub("all_esty","all_in", colnames(fe2es))
  } else {
    fe2es = NULL
  }
  ppfenfromes    <- readGDX(gdx,name=c("ppfEnFromEs","ppfenfromes"),types="sets",format="first_found", react = "silent")
  finenbalfehos  <- finenbal %>% filter(.data$all_enty == "fehos")
  ppfKap  <- readGDX(gdx,"ppfKap")

  ppfen_stat <- readGDX(gdx,c("ppfen_stationary_dyn38","ppfen_stationary_dyn28","ppfen_stationary"),format="first_found", react = "silent")
  if (length(ppfen_stat) == 0) ppfen_stat = NULL
  ppfen_build <- readGDX(gdx,c("ppfen_buildings_dyn36","ppfen_buildings_dyn28","ppfen_buildings"),format="first_found", react = "silent")
  ue_dyn36 <- readGDX(gdx,c("ue_dyn36"),format="first_found", react = "silent")
  ppfen_build <- setdiff(ppfen_build, ue_dyn36)
  ppfen_ind <- readGDX(gdx,c("ppfen_industry_dyn37","ppfen_industry_dyn28","ppfen_industry"),format="first_found", react = "silent")
  ppfen_stat_build_ind <- c(ppfen_stat,ppfen_build,ppfen_ind)

  # Realisation of the different modules
  if ( !is.null(realisation) & (!"CES_structure" %in% realisation[, 1] )){
    stat_mod = find_real_module(realisation,"stationary")
    tran_mod = find_real_module(realisation,"transport")
    indu_mod = find_real_module(realisation,"industry")
    buil_mod = find_real_module(realisation,"buildings")
  } else {
    if ( !is.null(ppfen_stat)){   # In case the set realisation did not exist, find out whether it was stationary or buildings-industry
      stat_mod = "simple"
      indu_mod = "off"
      buil_mod = "off"
    } else {
      stat_mod = "off"
      indu_mod = "fixed_shares"
      buil_mod = "simple"
    }
  }

  if (indu_mod %in% c('fixed_shares', 'subsectors')) {
    fe2ppfen37 <- readGDX(gdx, 'fe2ppfen') %>%
      filter(.data$all_in %in% ppfen_ind)
  }

  ## parameter
  shift_p        <- readGDX(gdx,name="p30_pebiolc_pricshift",format="first_found")
  mult_p         <- readGDX(gdx,name="p30_pebiolc_pricmult",format="first_found")
  pric_mag       <- readGDX(gdx,name="p30_pebiolc_pricemag",format="first_found")
  pric_emu_pre   <- readGDX(gdx,name="p30_pebiolc_price_emu_preloop",format="first_found")
  pric_emu_pre_shifted <- readGDX(gdx,name="p30_pebiolc_price_emu_preloop_shifted",format="first_found")
  bio_tax_factor <- readGDX(gdx,name="p21_tau_bioenergy_tax",format="first_found")
  pm_pvp        <- readGDX(gdx,name=c("pm_pvp","p80_pvp"),format="first_found")[,,p80_subset]
  pm_ts          <- readGDX(gdx,name='pm_ts',format="first_found")
  pm_dataemi     <- readGDX(gdx,name=c("pm_emifac","pm_dataemi"),format="first_found",restore_zeros=FALSE)[,,c("pegas.seel.ngt.co2","pecoal.seel.pc.co2")]
  pm_pvpRegi     <- readGDX(gdx,name='pm_pvpRegi',format="first_found")[,,"perm"]
  pm_taxCO2eq    <- readGDX(gdx,name=c("pm_taxCO2eq","pm_tau_CO2_tax"),format="first_found")
  pm_taxCO2eqSCC     <- readGDX(gdx,name='pm_taxCO2eqSCC',format="first_found")
  pm_delta_kap <- readGDX(gdx, c("pm_delta_kap", "p_delta_kap"), format = "first_found")
  if(is.null(getNames(pm_delta_kap))) pm_delta_kap = setNames(pm_delta_kap,"kap")
  pm_taxemiMkt <- readGDX(gdx,name="pm_taxemiMkt",format="first_found")
  ## variables
  pric_emu       <- readGDX(gdx,name="vm_pebiolc_price",field="l",format="first_found")
  prodFE         <- readGDX(gdx,name='vm_prodFe',field="l",format="first_found",restore_zeros = FALSE)
  prodSE         <- readGDX(gdx,name='vm_prodSe',field="l",format="first_found",restore_zeros = FALSE)
  cesIO          <- readGDX(gdx,name='vm_cesIO',types="variables",field="l",format="first_found",restore_zeros=FALSE)

  fe_tax <- readGDX(gdx, name=c("pm_tau_fe_tax"), format="first_found", react = "silent")
  fe_sub <- readGDX(gdx, name=c("pm_tau_fe_sub"), format="first_found", react = "silent")
  if(is.null(fe_tax)){
    fe_taxCES  <- readGDX(gdx, name=c('p21_tau_fe_tax','pm_tau_fe_tax'), format="first_found", react = F)[ppfen_stat_build_ind]
    fe_subCES  <- readGDX(gdx, name=c('p21_tau_fe_sub','pm_tau_fe_sub'), format="first_found", react = F)[ppfen_stat_build_ind]
    if(is.null(fe_taxCES) & is.null(fe_subCES)){
      fe_taxCES = readGDX(gdx, name=c('pm_tau_fe_tax_bit_st','p21_tau_fe_tax_bit_st'), format= "first_found")[,,ppfen_stat_build_ind]
      fe_subCES = readGDX(gdx, name=c('pm_tau_fe_sub_bit_st','p21_tau_fe_sub_bit_st'), format= "first_found")[,,ppfen_stat_build_ind]

    }
    getSets(fe_taxCES) = gsub("all_enty","all_in", getSets(fe_taxCES))
    getSets(fe_subCES) = gsub("all_enty","all_in", getSets(fe_subCES))
    if (!is.null(all_esty) ){
      fe_taxES =  readGDX(gdx, name=c("pm_tau_fe_tax_ES_st",'p21_tau_fe_tax_ES_st'),format = "first_found", react = "silent")
      fe_subES =  readGDX(gdx, name=c('pm_tau_fe_sub_ES_st','p21_tau_fe_sub_ES_st'),format = "first_found", react = "silent")
      if (!is.null(fe_taxES)){
        getSets(fe_taxES) = gsub("all_esty","all_in", getSets(fe_taxES))
        getSets(fe_subES) = gsub("all_esty","all_in", getSets(fe_subES))
      }
    } else {
      fe_taxES = NULL
      fe_subES = NULL
    }
  }
  ## equations
  pebal.m        <- readGDX(gdx,name=c("q_balPe","qm_pebal"),types = "equations",field = "m",format = "first_found")[,,pebal_subset]
  budget.m       <- readGDX(gdx,name='qm_budget',types = "equations",field = "m",format = "first_found") # Alternative: calcPrice
  sebal.m        <- readGDX(gdx,name=c("q_balSe","q_sebal"),types="equations",field="m",format="first_found")
  balcapture.m   <- readGDX(gdx,name=c("q_balcapture", "q12_balcapture"), field = "m", restore_zeros = F)
  if (!is.null(power_realisation)) {
    sebalSeel.m    <- readGDX(gdx,name="q32_balSe",types="equations",field="m",format="first_found")
  }
  esm2macro.m    <- readGDX(gdx,name='q35_esm2macro',types="equations",field="m",format="first_found")
  febal.m        <- readGDX(gdx,name=c("qm_balFe","q_balFe","q_febal"),types="equations",field="m",format="first_found",restore_zeros=FALSE)[,,fety]
  balfinen.m     <- readGDX(gdx,name=c("qm_balFeForCesAndEs","qm_balFeForCes","q_balFeForCes","q_balfinen"),types="equations",field="m",format="first_found", react = "silent")

  if(is.null(balfinen.m)){
    # aggregating febal to have the expected dimension by the older reporting code
    febal.m <- setNames(febal.m, gsub(".([^.]*)$","",getNames(febal.m)))
    mapping <- data.frame(from = getNames(febal.m),to = gsub("^[^.]+.","",getNames(febal.m)))
    w <- setNames(prodFE[,,getNames(febal.m)], gsub(".([^.]*)$","",getNames(prodFE[,,getNames(febal.m)])))
    febal.m <- toolAggregate(dimReduce(febal.m,3),mapping,weight = w, dim=3)
    balfinen.m <- febal.m
  }

  cm_emiscen     <- readGDX(gdx,name='cm_emiscen',format="first_found")

  q37_limit_secondary_steel_share.m <- readGDX(
    gdx, name = 'q37_limit_secondary_steel_share', types = 'equation',
    field = 'm', react = 'silent')

  #####################################
  #choose the CES entries names for transport
  if (!is.null(esm2macro.m)) {
  name_trsp=c("fepet","ueLDVt","fedie","ueHDVt","feelt","ueelTt")
  name_trsp=name_trsp[name_trsp%in%getNames(esm2macro.m)]
  }
  #####################################

  ####### calculate minimal temporal resolution #####
  y <- Reduce(intersect,list(getYears(febal.m, as.integer = T),getYears(prodFE, as.integer = T),getYears(sebal.m, as.integer = T),getYears(prodSE, as.integer = T)))
  febal.m        <- febal.m[,y,]
  balfinen.m     <- balfinen.m[,y,]
  budget.m       <- budget.m[,y,]
  sebal.m        <- sebal.m[,y,]
  if (!is.null(power_realisation)) {
    sebalSeel.m    <- sebalSeel.m[,y,]
  }
  pm_pvp         <- pm_pvp[,y,]
  pebal.m        <- pebal.m[,y,]
  shift_p        <- shift_p[,y,]
  mult_p         <- mult_p[,y,]
  pric_mag       <- pric_mag[,y,]
  pric_emu_pre   <- pric_emu_pre[,y,]
  pric_emu_pre_shifted <- pric_emu_pre_shifted[,y,]
  pric_emu       <- pric_emu[,y,]
  bio_tax_factor <- bio_tax_factor[,y,]
  if (!is.null(esm2macro.m)) {
  esm2macro.m    <- esm2macro.m[,y,]
  }
  pm_dataemi     <- pm_dataemi[,y,]
  pm_ts          <- pm_ts[,y,]
  pm_pvpRegi     <- pm_pvpRegi[,y,]
  pm_taxCO2eq    <- pm_taxCO2eq[,y,]
  if (!is.null(pm_taxemiMkt)){
        pm_taxemiMkt <- pm_taxemiMkt[,y,]
  }
  if (!is.null(pm_taxCO2eqSCC)) {
       pm_taxCO2eqSCC <- pm_taxCO2eqSCC[,y,]
  }
  cesIO <- cesIO[,y,]

  ####### pm_pvp = EPS results in fantasy carbon prices
    for(t in getYears(pm_pvp)){
     if(pm_pvp[,t,"good"] == 0){
         pm_pvp[,t,"good"] = 0.0001;
         }
    }

  ####### calculate reporting parameters ############
  tmp <- NULL


  # Calculate and append new variables to magpie object
  # Costs and prices for purpose-grown 2nd gen. bioenergy
  # - Shiftfactor
  # - imported values from MAgPIE reporting
  # - results from emulator based on MAgPIE demand (before main solve)
  # - results from emulator based on MAgPIE demand multiplied with shiftfactor (before main solve)
  # - results from emulator based on REMIND demand (after main solve)
  # - results from emulator based on REMIND demand multiplied with shiftfactor (after main solve)

  time <- getYears(budget.m,as.integer=TRUE)
  regs <- getRegions(budget.m)

  # report variables
  tmp <- NULL
  tmp <- mbind(tmp,setNames(shift_p,                                                   "Internal|Price|Biomass|Shiftfactor ()"))
  tmp <- mbind(tmp,setNames(mult_p,                                                    "Internal|Price|Biomass|Multfactor ()"))
  tmp <- mbind(tmp,setNames(pric_mag * tdptwyr2dpgj,                                   "Internal|Price|Biomass|MAgPIE (US$2005/GJ)"))
  tmp <- mbind(tmp,setNames(pric_emu_pre * tdptwyr2dpgj,                               "Internal|Price|Biomass|Emulator presolve (US$2005/GJ)"))
  tmp <- mbind(tmp,setNames(pric_emu_pre_shifted * tdptwyr2dpgj,                       "Internal|Price|Biomass|Emulator presolve shifted (US$2005/GJ)"))
  tmp <- mbind(tmp,setNames(pric_emu * tdptwyr2dpgj,                                   "Internal|Price|Biomass|Emulator shifted (US$2005/GJ)"))
  tmp <- mbind(tmp,setNames(pric_emu * bio_tax_factor * tdptwyr2dpgj,             "Internal|Price|Biomass|Bioenergy tax (US$2005/GJ)"))


  # energy services
  if (!is.null(esm2macro.m)) {
    tmp <- mbind(tmp,setNames(abs(esm2macro.m[,,name_trsp[2]]/(budget.m+1e-10)) * tdptwyr2dpgj , "Price|Energy Service|Transport nonLDV (US$2005/GJ)"))
    tmp <- mbind(tmp,setNames(abs(esm2macro.m[,,name_trsp[1]]/(budget.m+1e-10)) * tdptwyr2dpgj , "Price|Energy Service|Transport LDV (US$2005/GJ)"))
  }


  tmp <- mbind(tmp,setNames(abs(pm_pvpRegi / (pm_pvp[,,"good"] + 1e-10)) * 1000 * 12/44, "Price|Carbon (US$2005/t CO2)"))
  tmp <- mbind(tmp,setNames(abs(pm_taxCO2eq) * 1000 * 12/44, "Price|Carbon|Guardrail (US$2005/t CO2)"))
  CaptureBal_tmp <- new.magpie(getRegions(tmp), getYears(tmp), fill = NA)
  CaptureBal_tmp[,getYears(balcapture.m),] <- balcapture.m
  tmp <- mbind(tmp, setNames(CaptureBal_tmp / (budget.m+1e-10) / 3.66 * 1e3,
               "Price|Carbon|Captured (US$2005/t CO2)"))

  if (is.null(regionSubsetList$EUR)) {
    tmp <- mbind(tmp,setNames(pm_taxCO2eq * 1000 * 12/44, "Price|Carbon|EU-wide Regulation For All Sectors (US$2005/t CO2)"))
  } else {
    co2EUprice <- pm_taxCO2eq * 1000 * 12/44
    co2EUprice[getRegions(pm_taxCO2eq)[!getRegions(pm_taxCO2eq) %in% regionSubsetList$EUR],,] <- 0
    priceReg <- regionSubsetList$EUR[!regionSubsetList$EUR %in% c("DEU","FRA","EUC","EUW")][1] #select region to define EU price (excluding Germany and France)
    for (r in regionSubsetList$EUR){
      co2EUprice[r,,] <- as.vector(co2EUprice[priceReg,,])
    }
    tmp <- mbind(tmp,setNames(co2EUprice, "Price|Carbon|EU-wide Regulation For All Sectors (US$2005/t CO2)"))
  }

  if (!is.null(pm_taxemiMkt)) {
    tmp <- mbind(tmp,setNames(pm_taxemiMkt[,,"ETS"] * 1000 * 12/44, "Price|Carbon|ETS (US$2005/t CO2)"))
    tmp <- mbind(tmp,setNames(pm_taxemiMkt[,,"ES"] * 1000 * 12/44, "Price|Carbon|National Climate Target Non-ETS (US$2005/t CO2)"))
    tmp <- mbind(tmp,setNames(pm_taxemiMkt[,,"ES"] * 1000 * 12/44, "Price|Carbon|ESD (US$2005/t CO2)"))
  }

  if (!is.null(pm_taxCO2eqSCC)) {
      tmp <- mbind(tmp,setNames(abs(pm_taxCO2eqSCC) * 1000 * 12/44, "Price|Carbon|SCC (US$2005/t CO2)"))
  }

  tmp <- mbind(tmp,setNames(tmp[,,"Price|Carbon (US$2005/t CO2)"] * s_GWP_N2O, "Price|N2O (US$2005/t N2O)"))
  tmp <- mbind(tmp,setNames(tmp[,,"Price|Carbon (US$2005/t CO2)"] * s_GWP_CH4, "Price|CH4 (US$2005/t CH4)"))


  # ---- mapping of weights for the variables for global aggregation ----
  int2ext <- c(
    "Price|Primary Energy|Biomass|Modern (US$2005/GJ)"                = "PE|Biomass|Modern (EJ/yr)",
    "Price|Primary Energy|Oil (US$2005/GJ)"      = "PE|+|Oil (EJ/yr)",
    "Price|Primary Energy|Gas (US$2005/GJ)"      = "PE|+|Gas (EJ/yr)",
    "Price|Primary Energy|Coal (US$2005/GJ)"     = "PE|+|Coal (EJ/yr)",
    "Price|Primary Energy|Nuclear (US$2005/GJ)"     = "PE|+|Nuclear (EJ/yr)",
    "Price|Primary Energy|Biomass|1st Generation|Sugar and Starch (US$2005/GJ)" = "PE|Biomass|1st Generation (EJ/yr)",
    "Price|Primary Energy|Biomass|1st Generation|Oil-based (US$2005/GJ)" = "PE|Biomass|1st Generation (EJ/yr)",

    "Internal|Price|Biomass|Emulator presolve (US$2005/GJ)"            = "Primary Energy Production|Biomass|Energy Crops MAgPIE (EJ/yr)",
    "Internal|Price|Biomass|Emulator presolve shifted (US$2005/GJ)"    = "Primary Energy Production|Biomass|Energy Crops MAgPIE (EJ/yr)",
    "Internal|Price|Biomass|Emulator shifted (US$2005/GJ)"             = "Primary Energy Production|Biomass|Energy Crops (EJ/yr)",
    "Internal|Price|Biomass|MAgPIE (US$2005/GJ)"                       = "Primary Energy Production|Biomass|Energy Crops MAgPIE (EJ/yr)",
    "Internal|Price|Biomass|Bioenergy tax (US$2005/GJ)"                = "Primary Energy Production|Biomass|Energy Crops (EJ/yr)",
    "Price|N2O (US$2005/t N2O)"                               = "Emi|N2O (kt N2O/yr)",
    "Price|CH4 (US$2005/t CH4)"                               = "Emi|CH4 (Mt CH4/yr)",
    "Price|Secondary Energy|Electricity (US$2005/GJ)"            = "SE|Electricity (EJ/yr)",
    "Price|Secondary Energy|Hydrogen (US$2005/GJ)"            = "SE|Hydrogen (EJ/yr)",
    "Price|Secondary Energy|Heat (US$2005/GJ)"                = "SE|Heat (EJ/yr)",
    "Price|Secondary Energy|Solids|Biomass (US$2005/GJ)"            = "SE|Solids|Biomass (EJ/yr)",
    "Price|Secondary Energy|Liquids|Biomass (US$2005/GJ)"             = "SE|Liquids|Biomass (EJ/yr)",
    "Price|Secondary Energy|Gases|Biomass (US$2005/GJ)"             = "SE|Gases|Biomass (EJ/yr)",
    "Price|Secondary Energy|Solids|Fossil (US$2005/GJ)"            = "SE|Solids|Coal (EJ/yr)",
    "Price|Secondary Energy|Liquids|Fossil (US$2005/GJ)"             = "SE|Liquids|Oil (EJ/yr)",
    "Price|Secondary Energy|Gases|Fossil (US$2005/GJ)"             = "SE|Gases|Fossil (EJ/yr)",
    "Price|Secondary Energy|Liquids|Hydrogen (US$2005/GJ)"             = "SE|Liquids|Hydrogen (EJ/yr)",
    "Price|Secondary Energy|Gases|Hydrogen (US$2005/GJ)"             = "SE|Gases|Hydrogen (EJ/yr)",
    "Price|Carbon|ETS (US$2005/t CO2)"                        = "Emi|GHG|++|ETS (Mt CO2eq/yr)",
    "Price|Carbon|National Climate Target Non-ETS (US$2005/t CO2)" = "Emi|GHG|++|Other (Mt CO2eq/yr)",
    "Price|Carbon|ESD (US$2005/t CO2)"                        = "Emi|GHG|++|ESR (Mt CO2eq/yr)"
    )

  if (!is.null(esm2macro.m)) {
    int2ext <- c(int2ext,
                 "Price|Energy Service|Transport LDV (US$2005/GJ)"         = "CES_input|fepet (EJ/yr)",  ## TODO: check units
                 "Price|Energy Service|Transport nonLDV (US$2005/GJ)"      = "CES_input|fedie (EJ/yr)"  ## TODO: check units
    )
  }

  if (all(cm_emiscen == 9)) int2ext <- c(int2ext, c( "Price|Carbon (US$2005/t CO2)"  = "Internal|Emi|GHG|Emissions to which global CO2 tax is applied (Mt CO2eq/yr)"))


  ## weights definition for region aggregtation
  int2ext <- c(int2ext,

               ## transport prices
               "Price|Final Energy|Transport|Electricity (US$2005/GJ)"       = "FE|Transport|+|Electricity (EJ/yr)",
               "Price|Final Energy|Transport|Liquids (US$2005/GJ)"       = "FE|Transport|+|Liquids (EJ/yr)",
               "Price|Final Energy|Transport|Hydrogen (US$2005/GJ)"       = "FE|Transport|+|Hydrogen (EJ/yr)",

               ## buildings prices
               "Price|Final Energy|Buildings|Electricity (US$2005/GJ)"       = "FE|Buildings|+|Electricity (EJ/yr)",
               "Price|Final Energy|Buildings|Liquids (US$2005/GJ)"       = "FE|Buildings|+|Liquids (EJ/yr)",
               "Price|Final Energy|Buildings|Gases (US$2005/GJ)"       = "FE|Buildings|+|Gases (EJ/yr)",
               "Price|Final Energy|Buildings|Hydrogen (US$2005/GJ)"       = "FE|Buildings|+|Hydrogen (EJ/yr)",
               "Price|Final Energy|Buildings|Heat (US$2005/GJ)"       = "FE|Buildings|+|Heat (EJ/yr)",
               "Price|Final Energy|Buildings|Solids (US$2005/GJ)"       = "FE|Buildings|+|Solids (EJ/yr)",

               ## industry prices
               "Price|Final Energy|Industry|Electricity (US$2005/GJ)"       = "FE|Industry|+|Electricity (EJ/yr)",
               "Price|Final Energy|Industry|Liquids (US$2005/GJ)"       = "FE|Industry|+|Liquids (EJ/yr)",
               "Price|Final Energy|Industry|Gases (US$2005/GJ)"       = "FE|Industry|+|Gases (EJ/yr)",
               "Price|Final Energy|Industry|Hydrogen (US$2005/GJ)"       = "FE|Industry|+|Hydrogen (EJ/yr)",
               "Price|Final Energy|Industry|Heat (US$2005/GJ)"       = "FE|Industry|+|Heat (EJ/yr)",
               "Price|Final Energy|Industry|Solids (US$2005/GJ)"       = "FE|Industry|+|Solids (EJ/yr)"
               )


  if (module2realisation["transport",2] == "edge_esm") {
    int2ext <- c(int2ext,
                 "Price|Final Energy|Transport|Gases (US$2005/GJ)"       = "FE|Transport|+|Gases (EJ/yr)")
  }

  ## bind new price variables to old variables
  tmp <- mbind(tmp, out)

  ## moving averages
  avgs <- grep("Moving Avg", getNames(tmp), value=TRUE)
  int2ext <- c(int2ext, stats::setNames(int2ext[gsub("\\|Moving Avg", "", avgs)], avgs))

  output[is.na(output)] <- 0  # substitute na by 0

  # add global prices
  map <- data.frame(region=getRegions(tmp),world="GLO",stringsAsFactors=FALSE)
  tmp_GLO <- new.magpie("GLO",getYears(tmp),magclass::getNames(tmp),fill=0)

  for (i2e in names(int2ext)){
    tmp_GLO["GLO",,i2e] <- speed_aggregate(tmp[,,i2e],map,weight=output[map$region,,int2ext[i2e]])
    for(t in getYears(tmp)){
      if(all(output[map$region,t,int2ext[i2e]]==0)){
        tmp_GLO["GLO",t,i2e] <- NA
      }
    }
  }
  tmp <- mbind(tmp,tmp_GLO)

  # add other region aggregations
  if (!is.null(regionSubsetList)){
    tmp_RegAgg <- new.magpie(names(regionSubsetList),getYears(tmp),magclass::getNames(tmp),fill=0)
    for(region in names(regionSubsetList)){
      tmp_RegAgg_ie2 <- do.call("mbind",lapply(names(int2ext), function(i2e) {
        map <- data.frame(region=regionSubsetList[[region]],parentRegion=region,stringsAsFactors=FALSE)
        result <- speed_aggregate(tmp[regionSubsetList[[region]],,i2e],map,weight=output[regionSubsetList[[region]],,int2ext[i2e]])
        getRegions(result) <- region
        for(t in getYears(tmp)){
          if(all(output[regionSubsetList[[region]],t,int2ext[i2e]]==0)){
            result[region,t,i2e] <- NA
          }
        }
        return(result)
      }))
      tmp_RegAgg[region,,names(int2ext)] <- tmp_RegAgg_ie2[region,,names(int2ext)]
    }
    tmp <- mbind(tmp,tmp_RegAgg)
  }

  tmp[is.na(tmp)] <- 0  # tmp is NA if weight is zero for all regions within the GLO or the specific region aggregation. Therefore, we replace all NAs with zeros.

  # prices that are same for all regions, including GLO
  glob_price <- new.magpie(getRegions(tmp),getYears(tmp),fill=0)
  for(i in getRegions(tmp)) glob_price[i,,] <- pm_pvp[,,"peur"]*1000
  tmp <- mbind(tmp,setNames(glob_price,                             "PVP1|Uranium (billionDpktU)"))
  for(i in getRegions(tmp)) glob_price[i,,] <- pm_pvp[,,"peoil"]*1000
  tmp <- mbind(tmp,setNames(glob_price,                             "PVP1|Oil (billionDpTWyr)"))
  for(i in getRegions(tmp)) glob_price[i,,] <- pm_pvp[,,"pegas"]*1000
  tmp <- mbind(tmp,setNames(glob_price,                             "PVP1|Gas (billionDpTWyr)"))
  for(i in getRegions(tmp)) glob_price[i,,] <- pm_pvp[,,"pecoal"]*1000
  tmp <- mbind(tmp,setNames(glob_price,                             "PVP1|Coal (billionDpTWyr)"))
  for(i in getRegions(tmp)) glob_price[i,,] <- pm_pvp[,,"pebiolc"]*1000
  tmp <- mbind(tmp,setNames(glob_price,                             "PVP1|Biomass (billionDpTWyr)"))
  for(i in getRegions(tmp)) glob_price[i,,] <- pm_pvp[,,"good"]*1000
  tmp <- mbind(tmp,setNames(glob_price,                             "PVP2|Good ()"))
  for(i in getRegions(tmp)) glob_price[i,,] <- pm_pvp[,,"perm"]
  tmp <- mbind(tmp,setNames(glob_price,                             "PVP3|Permit ()"))

  for(i in getRegions(tmp)) glob_price[i,,] <- pm_pvp[,,"peur"]/pm_pvp[,,"good"] * tdptwyr2dpgj
  tmp <- mbind(tmp,setNames(glob_price,                                       "Price|Uranium|World Market (US$2005/GJ)"))
  for(i in getRegions(tmp)) glob_price[i,,] <- pm_pvp[,,"peoil"]/pm_pvp[,,"good"] * tdptwyr2dpgj
  tmp <- mbind(tmp,setNames(glob_price,                                       "Price|Oil|World Market (US$2005/GJ)"))
  for(i in getRegions(tmp)) glob_price[i,,] <- pm_pvp[,,"pegas"]/pm_pvp[,,"good"] * tdptwyr2dpgj
  tmp <- mbind(tmp,setNames(glob_price,                                       "Price|Gas|World Market (US$2005/GJ)"))
  for(i in getRegions(tmp)) glob_price[i,,] <- pm_pvp[,,"pecoal"]/pm_pvp[,,"good"] * tdptwyr2dpgj
  tmp <- mbind(tmp,setNames(glob_price,                                       "Price|Coal|World Market (US$2005/GJ)"))
  for(i in getRegions(tmp)) glob_price[i,,] <- pm_pvp[,,"pebiolc"]/pm_pvp[,,"good"] * tdptwyr2dpgj
  tmp <- mbind(tmp,setNames(glob_price,                                       "Price|Biomass|World Market (US$2005/GJ)"))

  ## special global prices

  #AJS calc global carbon price as average over regional pm_pvpRegi's, weighted by total emissions.
  regi_on_gdx <- unique(readGDX(gdx, name = "regi2iso")[,1])

  tmp["GLO",,"Price|Carbon (US$2005/t CO2)"] <-
    dimSums( pm_pvpRegi[regi_on_gdx,,"perm"] * output[regi_on_gdx,,"Internal|Emi|GHG|Emissions to which global CO2 tax is applied (Mt CO2eq/yr)"],dim=1 ) /
    dimSums(output[regi_on_gdx,,"Internal|Emi|GHG|Emissions to which global CO2 tax is applied (Mt CO2eq/yr)"],dim=1) /
    (pm_pvp[1,,"good"] + 1e-10) * 1000*12/44

  # add other region aggregations carbon price as average over regional pm_pvpRegi's, weighted by total emissions.
  if (!is.null(regionSubsetList)){
    for(region in names(regionSubsetList)){
      tmp[region,,"Price|Carbon (US$2005/t CO2)"] <- dimSums( pm_pvpRegi[regionSubsetList[[region]],,"perm"] * output[regionSubsetList[[region]],,"Internal|Emi|GHG|Emissions to which global CO2 tax is applied (Mt CO2eq/yr)"],dim=1 ) /
        dimSums(output[regionSubsetList[[region]],,"Internal|Emi|GHG|Emissions to which global CO2 tax is applied (Mt CO2eq/yr)"],dim=1) /
        (pm_pvp[1,,"good"] + 1e-10) * 1000*12/44;
    }
  }

  ## not meaningful global prices set to NA
  tmp["GLO",,"Internal|Price|Biomass|Shiftfactor ()"] <- NA

  if (!is.null(regionSubsetList$EUR))
    tmp["EUR",,"Price|Carbon|EU-wide Regulation For All Sectors (US$2005/t CO2)"] <- as.vector(co2EUprice[priceReg,,])

  ## not meaningful region aggregation prices set to NA
  if (!is.null(regionSubsetList)){
    for(region in names(regionSubsetList)){
      tmp[region,,"Internal|Price|Biomass|Shiftfactor ()"] <- NA
    }
  }

  # ---- debug information for industry/subsectors ----
  if ('subsectors' == indu_mod & !is.null(q37_limit_secondary_steel_share.m)) {
    .x <- q37_limit_secondary_steel_share.m[,y,] / budget.m
    .x <- mbind(.x, calc_regionSubset_sums(.x, regionSubsetList))

    tmp2 <- mbind(
      # fake some GLO data
      setNames(
        mbind(.x, dimSums(.x * NA, dim = 1)),
        'Debug|Industry|Secondary Steel Premium (US$2005)'),

      mbind(
        lapply(
          list(
            c('ue_industry',        '',                 'arbitrary unit', 1),
            c('ue_cement',          '|Cement',          't cement',       1e3),
            c('ue_chemicals',       '|Chemicals',       'arbitrary unit', 1),
            c('ue_steel',           '|Steel',           't Steel',        1e3),
            c('ue_steel_primary',   '|Steel|Primary',   't Steel',        1e3),
            c('ue_steel_secondary', '|Steel|Secondary', 't Steel',        1e3),
            c('ue_otherInd',        '|other',           'arbitrary unit', 1)),
          function(x) {
            setNames(
              ( tmp[,,paste0('Price|CES_input|', x[1], ' ('), pmatch = 'left']
                * as.numeric(x[4])
              ),
              paste0('Debug|Price|Industry', x[2], ' (US$2005/', x[3], ')'))
          })
      )
    )

    tmp <- mbind(tmp, tmp2)
  }

  return(tmp)
}
