#' Reports emissions & air pollutant values from GDX for climate assessment in between Nash iterations
#'
#' @param gdx a GDX as created by readGDX, or the file name of a gdx
#' @param output a magpie object containing all needed variables generated by other report*.R functions
#' @param regionSubsetList a list containing regions to create report variables region
#' aggregations. If NULL (default value) only the global region aggregation "GLO" will
#' be created.
#' @param t temporal resolution of the reporting, default:
#' t=c(seq(2005,2060,5),seq(2070,2110,10),2130,2150)
#'
#' @author Gabriel Abrahao, Tonn Rüter, Felix Schreyer, Simón Moreno Leiva
#' @examples
#' \dontrun{
#' reportEmiForClimateAssessment(gdx)
#' }
#' @export
#'
#' @importFrom gdx readGDX
#' @importFrom magclass mbind mselect mselect<- getItems getRegions getYears getSets dimSums new.magpie

require(gdx)
require(magclass)
require(dplyr)
source("./R/reportFE.R")
source("./R/reportEmiAirPol.R")

reportEmiForClimateAssessment <- function(gdx, output = NULL, regionSubsetList = NULL,
                                          t = c(seq(2005, 2060, 5), seq(2070, 2110, 10), 2130, 2150)) {
  # emissions calculation requires information from other reporting functions
  # if (is.null(output)) {
  #   message("reportEmi executes reportFE")
  #   output <- mbind(output, reportFE(gdx, regionSubsetList = regionSubsetList, t = t))
  # }

  # if (is.null(output)) {
  # # Error in `.dimextract()`:
  # # ! subscript out of bounds ("GLO")
  # # Run `rlang::last_trace()` to see where the error occurred.
  # # > rlang::last_trace()
  # # <error/rlang_error>
  # # Error in `.dimextract()`:
  # # ! subscript out of bounds ("GLO")
  # # ---
  # # Backtrace:
  # #     ▆
  # #  1. └─global reportEmiForClimateAssessment(postsolve_gdx_path)
  # #  2.   ├─magclass::mbind(...)
  # #  3.   └─global reportEmiAirPol(gdx, regionSubsetList = regionSubsetList, t = t)
  # #  4.     ├─methods (local) `[<-`(`*tmp*`, "GLO", , , value = `<magpie[,40,2]>`) at ./R/reportEmiAirPol.R:114:7
  # #  5.     └─magclass (local) `[<-`(`*tmp*`, "GLO", , , value = `<magpie[,40,2]>`)
  # #  6.       └─magclass (local) .local(x, i, j, ..., value = value)
  # #  7.         └─magclass:::.dimextract(x, i, 1, pmatch = pmatch)
  #   message("reportEmiForClimateAssessment executes reportAirPol")
  #   output <- mbind(output, reportEmiAirPol(gdx, regionSubsetList = regionSubsetList, t = t))
  # }

  # intialize varibles used in dplyr operations

  # Read Data from GDX ----

  ####### get realisations #########
  module2realisation <- readGDX(gdx, "module2realisation")
  rownames(module2realisation) <- module2realisation$modules


  # unit conversion parameters needed
  sm_c_2_co2 <- readGDX(gdx, "sm_c_2_co2")
  GtC_2_MtCO2 <- sm_c_2_co2 * 1000 # conversion of GtC to MtCO2
  MtN2_to_ktN2O <- 44 / 28 * 1000 # conversion from MtN to ktN2O

  # other parameters required

  # switches relevant for emissions reporting

  # sets required
  emiMac2sector <- readGDX(gdx, "emiMac2sector") # mapping of MAC sectors to emissions sectors and gases
  macSector2emiMkt <- readGDX(gdx, "macSector2emiMkt") # mapping of MAC sectors to emissions markets

  # additional sets needed
  # SE carriers for solids, liquids, gases


  # SE carriers by origin

  if (is.null(entySEbio <- readGDX(gdx, "entySEbio", react = "silent")))
    entySEbio <- c("sesobio", "seliqbio", "segabio")

  if (is.null(entySEsyn <- readGDX(gdx, "entySEsyn", react = "silent")) ||
    (length(entySEbio) == length(entySEsyn) && all(entySEbio == entySEsyn))) {
    entySEsyn <- c("seliqsyn", "segasyn")
  }


  ### emissions variables from REMIND (see definitions in core/equations.gms)
  # total GHG emissions
  # total emissions by gas
  vm_emiAllMkt <- readGDX(gdx, "vm_emiAllMkt", field = "l", restore_zeros = FALSE)[, t, ]
  # total energy emissions from pe2se and se2fe conversions
  vm_emiTeDetailMkt <- readGDX(gdx, c("vm_emiTeDetailMkt", "v_emiTeDetailMkt"), field = "l", restore_zeros = FALSE)
  # total energy emissions in REMIND
  # emissions from MAC curves (non-energy emissions)
  vm_emiMacSector <- readGDX(gdx, "vm_emiMacSector", field = "l", restore_zeros = FALSE)[, t, ]
  # exogenous emissions (SO2, BC, OC)
  # F-Gases
  vm_emiFgas <- readGDX(gdx, "vm_emiFgas", field = "l", restore_zeros = FALSE)[, t, ]
  # Emissions from MACs (currently: all emissions outside of energy CO2 emissions)
  vm_emiMacSector <- readGDX(gdx, "vm_emiMacSector", field = "l", restore_zeros = FALSE)
  # energy extraction energy-related CO2 emissions
  v_emiEnFuelEx <- readGDX(gdx, "v_emiEnFuelEx", field = "l", restore_zeros = FALSE)
  # set to zero if not available
  if (is.null(v_emiEnFuelEx)) {
    v_emiEnFuelEx <- vm_emiMacSector[, , "co2"] * 0
  }

  # START OF BASICMODE
  # if basicmode is TRUE, we need only a subset of reported emissions.
  # This is meant to be used for the climate assessment, which has to be run
  # inside REMIND before some of the energy system variables are defined
  #
  # Most of the code here comes from the normal function. The only real difference is
  # that Emi|CO2|Energy and Industrial Processes is calculated from the difference between
  # total and LUC emissions.
  #
  # Only global values from this function should be used, as it also skips the subtraction
  # of certain non-regional sources, such as bunkers, from the regional information
  # } else {
  out <- NULL

  #### Markets for total CO2 emissions
  sel_vm_emiAllMkt_co2 <- if (getSets(vm_emiAllMkt)[[3]] == "emiTe") {
    mselect(vm_emiAllMkt, emiTe = "co2")
  } else {
    mselect(vm_emiAllMkt, all_enty = "co2")
  }

  # Basic Total CO2 emissions
  out <- mbind(
    out,
    setNames(dimSums(sel_vm_emiAllMkt_co2, dim = 3) * GtC_2_MtCO2, "Emi|CO2 (Mt CO2/yr)")
  )
  # Basic Land-use change CO2 emissions
  out <- mbind(
    out,
    setNames(dimSums(vm_emiMacSector[, , "co2luc"], dim = 3) * GtC_2_MtCO2, "Emi|CO2|+|Land-Use Change (Mt CO2/yr)")
  )

  # Basic Get Energy and Industrial Processes from the difference between total and Land-use change emissions, for
  # climate assessment
  out <- mbind(
    out,
    setNames(
      out[, , "Emi|CO2 (Mt CO2/yr)"] - out[, , "Emi|CO2|+|Land-Use Change (Mt CO2/yr)"],
      "Emi|CO2|Energy and Industrial Processes (Mt CO2/yr)"
    )
  )

  #  Basic Non-CO2 GHG Emissions

  # join mac mapping of sectors and markets
  mac.map <- right_join(emiMac2sector, macSector2emiMkt, by = "all_enty")

  # create magpie array with MAC emissions per sector, market and gas
  # MAC emissions comprise non-energy CO2, CH4, N2O emissions
  emiMAC <- new.magpie(
    getRegions(vm_emiMacSector),
    getYears(vm_emiMacSector),
    paste(
      mac.map$all_enty,
      mac.map$emi_sectors,
      mac.map$all_emiMkt,
      mac.map[[if ("emiAll" %in% names(mac.map)) "emiAll" else "all_enty1"]],
      sep = "."
    )
  )
  # rename dimensions for sake of understanding
  getSets(emiMAC) <- c("region", "year", "macsector", "sector", "emiMkt", "gas")
  emiMAC[, , mac.map$all_enty] <- vm_emiMacSector[, , mac.map$all_enty]

  ### Basic Energy CH4 and N2O emissions, by markets -------
  sel_vm_emiTeDetailMkt_ch4 <- if (getSets(vm_emiTeDetailMkt)[[6]] == "emiAll") {
    mselect(vm_emiTeDetailMkt, emiAll = "ch4")
  } else {
    mselect(vm_emiTeDetailMkt, all_enty2 = "ch4")
  }

  sel_vm_emiTeDetailMkt_n2o <- if (getSets(vm_emiTeDetailMkt)[[6]] == "emiAll") {
    mselect(vm_emiTeDetailMkt, emiAll = "n2o")
  } else {
    mselect(vm_emiTeDetailMkt, all_enty2 = "n2o")
  }

  out <- mbind(
    out,
    # total CH4 emissions
    setNames(
      dimSums(mselect(emiMAC, gas = "ch4"), dim = 3) + dimSums(sel_vm_emiTeDetailMkt_ch4, dim = 3),
      "Emi|CH4 (Mt CH4/yr)"
    ),
    # total N2O emissions
    setNames(
      (dimSums(mselect(emiMAC, gas = "n2o"), dim = 3) + dimSums(sel_vm_emiTeDetailMkt_n2o, dim = 3)) * MtN2_to_ktN2O,
      "Emi|N2O (kt N2O/yr)"
    )
  )

  ### Basic PFCs ----
  out <- mbind(
    out,
    setNames(vm_emiFgas[, , "emiFgasCF4"],      "Emi|CF4 (kt CF4/yr)"),
    setNames(vm_emiFgas[, , "emiFgasC2F6"],     "Emi|C2F6 (kt C2F6/yr)"),
    setNames(vm_emiFgas[, , "emiFgasC6F14"],    "Emi|C6F14 (kt C6F14/yr)"),
    setNames(vm_emiFgas[, , "emiFgasHFC"],      "Emi|HFC (kt HFC134a-equiv/yr)"),
    setNames(vm_emiFgas[, , "emiFgasHFC125"],   "Emi|HFC|HFC125 (kt HFC125/yr)"),
    setNames(vm_emiFgas[, , "emiFgasHFC134a"],  "Emi|HFC|HFC134a (kt HFC134a/yr)"),
    setNames(vm_emiFgas[, , "emiFgasHFC143a"],  "Emi|HFC|HFC143a (kt HFC143a/yr)"),
    setNames(vm_emiFgas[, , "emiFgasHFC227ea"], "Emi|HFC|HFC227ea (kt HFC227ea/yr)"),
    setNames(vm_emiFgas[, , "emiFgasHFC23"],    "Emi|HFC|HFC23 (kt HFC23/yr)"),
    setNames(vm_emiFgas[, , "emiFgasHFC245fa"], "Emi|HFC|HFC245fa (kt HFC245fa/yr)"),
    setNames(vm_emiFgas[, , "emiFgasHFC32"],    "Emi|HFC|HFC32 (kt HFC32/yr)"),
    setNames(vm_emiFgas[, , "emiFgasHFC43-10"], "Emi|HFC|HFC43-10 (kt HFC43-10/yr)"),
    setNames(vm_emiFgas[, , "emiFgasPFC"],      "Emi|PFC (kt CF4-equiv/yr)"),
    setNames(vm_emiFgas[, , "emiFgasSF6"],      "Emi|SF6 (kt SF6/yr)")
  )

  ### Basic F-Gases (Mt CO2eq)
  out <- mbind(
    out,
    # F-Gases
    setNames(vm_emiFgas[, , "emiFgasTotal"],
      "Emi|GHG|+|F-Gases (Mt CO2eq/yr)"
    )
  )

  # add global values
  out <- mbind(out, dimSums(out, dim = 1))

  # out <- mbind(out, dimSums(out, dim = 1))

  getSets(out)[3] <- "variable"
  return(out)
}

postsolve_gdx_path <- "/p/projects/piam/abrahao/tonns_stuff/reportemi_stuff/fulldata_postsolve.gdx"
emiForCA <- reportEmiForClimateAssessment(postsolve_gdx_path)



emiForCA
